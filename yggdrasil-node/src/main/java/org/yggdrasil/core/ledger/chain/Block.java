package org.yggdrasil.core.ledger.chain;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.SerializationUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yggdrasil.core.ledger.LedgerHashableItem;
import org.yggdrasil.core.ledger.transaction.Transaction;
import org.yggdrasil.core.ledger.transaction.TransactionInput;
import org.yggdrasil.core.ledger.transaction.TransactionOutPoint;
import org.yggdrasil.core.ledger.transaction.TransactionOutput;
import org.yggdrasil.core.serialization.HashSerializer;
import org.yggdrasil.core.utils.CryptoHasher;
import org.yggdrasil.core.utils.CryptoKeyGenerator;
import org.yggdrasil.core.utils.DateTimeUtil;
import org.yggdrasil.node.network.messages.payloads.BlockHeaderPayload;
import org.yggdrasil.node.network.messages.payloads.BlockMessage;
import org.yggdrasil.node.network.messages.payloads.TransactionPayload;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.spec.InvalidKeySpecException;
import java.time.ZonedDateTime;
import java.util.*;

/**
 * The Block is the main unit of data in Yggdrasil. Blocks contain
 * an identifier known as the index, a timestamp for data management / sorting,
 * an object that contains transactions, a link to a previous block (previousBlockHash)
 * and the current block hash (blockHash). Blocks can be queried by hash or index.
 *
 * @since 0.0.2
 * @author nathanielbunch
 */
@JsonInclude
@JsonIgnoreProperties(value = "nonce")
public final class Block implements LedgerHashableItem {

    // The height of the block in the chain. The block height will provide
    // a sense of "time" or indexed record of the general era when a block was
    // created.
    private final BigInteger blockHeight;
    // The real time stamp of the block's creation, stored in UTC in order to allow
    // for the block height to be directly correlated with the timestamp. In all readability,
    // this timestamp serves no purpose other than for human readability, since it is not
    // used by the system.
    private final ZonedDateTime timestamp;
    // The list of txns that are stored in the block after being mined. Once txns are confirmed
    // and the block stored, this list becomes immutable...a permanent record in the blockchain.
    private final List<Transaction> data;
    // The root of the block. Merkle roots are used for quickly traversing txns and blocks in
    // order to verify that the txns are valid and able to be processed.
    private final byte[] merkleRoot;
    // The record of the previous block's hash, serving as the chain that binds the blocks into
    // interconnected sections of the overall blockchain.
    @JsonSerialize(using = HashSerializer.class)
    private final byte[] previousBlockHash;
    // The current block's hash for identifying itself. This is used in the lambda expressions for
    // finding the block being queried.
    @JsonSerialize(using = HashSerializer.class)
    private byte[] blockHash;
    //The signature is the indicator that states a block is signed by a particular miner (bound to
    // a specific account on-chain. The signature is generated by the miner account signing the block's
    // hash.
    @JsonSerialize(using = HashSerializer.class)
    private byte[] signature;
    // A variable for incrementing until the difficulty threshold is met. Nonce helps enforce and facilitate
    // the overall block mining difficulty, which is dynamically adjusted across chain until the new block
    // submission is around 1 block every ~14 minutes, similar to bitcoin.
    private int nonce;

    // The constructor here is private. The reason being that across the code-base the general ideology is to
    // use the "builder" methodology. This is to further enforce the idea of immutability of data.
    private Block(Builder blockBuilder) throws NoSuchAlgorithmException {
        this.blockHeight = blockBuilder.blockHeight;
        this.timestamp = blockBuilder.timestamp;
        this.merkleRoot = blockBuilder.merkleRoot;
        this.data = blockBuilder.data;
        this.previousBlockHash = blockBuilder.previousBlock;
        this.nonce = blockBuilder.nonce;
        this.blockHash = CryptoHasher.hash(this);
    }

    /**
     * Returns a BigDecimal value that indicates the blockheight at the point a
     * block has been created.
     *
     * @return blockHeight
     */
    public BigInteger getBlockHeight() {
        return blockHeight;
    }

    /**
     * Returns the time and date that a block has been created in UCT time.
     *
     * @return timestamp
     */
    public ZonedDateTime getTimestamp() {
        return timestamp;
    }

    /**
     * Returns a byte array that represents the merkleRoot of the block.
     *
     * @return merkleRoot
     */
    public byte[] getMerkleRoot() {
        return merkleRoot;
    }

    /**
     * Returns the array of txns that are contained in the block.
     *
     * @return data
     */
    public List<Transaction> getData() {
        return data;
    }

    /**
     * Returns the previous block hash for identifying the past block
     * in the chain.
     *
     * @return previousBlockHash
     */
    public byte[] getPreviousBlockHash() {
        return previousBlockHash;
    }

    /**
     * Sets this current block's hash. Set during the building of the block
     * in the mining process.
     *
     * @param blockHash
     */
    public void setBlockHash(byte[] blockHash) {
        this.blockHash = blockHash;
    }

    /**
     * Returns this current block's hash.
     *
     * @return blockHash
     */
    public byte[] getBlockHash() {
        return blockHash;
    }

    /**
     * Returns the permanent verification signature for this block that was
     * generated by the original miner's account and verifiable against the
     * miner's address.
     *
     * @return
     */
    public byte[] getSignature() {
        return signature;
    }

    /**
     * Set the mining signature that was generated by the miner's account.
     *
     * @param signature
     */
    public void setSignature(byte[] signature) {
        this.signature = signature;
    }

    /**
     * Increment the nonce during the block-building phase of the mining process.
     * This function call to increment approach further solidifies the immutable
     * approach of data, where instead of directly accessing the nonce value, we
     * increment only through a method call.
     */
    public void incrementNonce() {
        this.nonce++;
    }

    /**
     * Returns the nonce value, which is just a simple int value. May need to be a
     * boxed integer object or a double in the future.
     *
     * @return nonce
     */
    public int getNonce() {
        return nonce;
    }

    /**
     * Returns a specific txn from the block, provided the txn hash for querying.
     *
     * @param txnHash
     * @return transaction
     */
    public Optional<Transaction> getTransaction(byte[] txnHash) {
        return this.data.stream().filter(ftxn -> ftxn.compareTxnHash(txnHash)).findFirst();
    }

    /**
     * A comparator function for comparing a provided block hash with this block's hash.
     *
     * @param blockHash
     * @return isSameBlockHash
     */
    public boolean compareBlockHash(byte[] blockHash) {
        try {
            for (int i = 0; i < blockHash.length; i++) {
                if (blockHash[i] != this.blockHash[i]) {
                    return false;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    /**
     * When printing to the terminal, we do not need all the data printed, typically, so
     * just print the block hash...converted to human-readable form of course. :-)
     *
     * @return
     */
    @Override
    public String toString() {
        return CryptoHasher.humanReadableHash(blockHash);
    }

    /**
     * Creates the genesis block for use in the chain with a set block hash and a single coinbase txn.
     *
     * @return
     * @throws Exception
     */
    public static Block genesis() throws Exception {
        TransactionOutput txnOut = new TransactionOutput(CryptoHasher.hashByteArray("6ad28d3fda4e10bdc0aaf7112f7818e181defa7e"), BigDecimal.valueOf(50));
        Transaction txn = Transaction.Builder.builder()
                .setTimestamp(DateTimeUtil.fromMessageTimestamp(1625616000))
                .setOriginAddress(null)
                .setDestinationAddress("6ad28d3fda4e10bdc0aaf7112f7818e181defa7e")
                .setTxnInputs(new TransactionInput[]{new TransactionInput((TransactionOutPoint) null, BigDecimal.valueOf(50))})
                .setTxnOutputs(new TransactionOutput[]{txnOut})
                .build();
        byte[] genesisData = new byte[0];
        genesisData = appendBytes(genesisData, txn.getTxnHash());
        genesisData = appendBytes(genesisData, txn.getTxnHash());
        byte[] genesisMerkleRoot = CryptoHasher.dhash(genesisData);
        return new Builder()
                .setBlockHeight(BigInteger.ONE)
                .setMerkleRoot(genesisMerkleRoot)
                .setPreviousBlock(null)
                .setData(Collections.singletonList(txn))
                .build();
    }

    /**
     * Gets the byte array of all data in the block used primarily for creating the block
     * hash.
     *
     * @return
     */
    @JsonIgnore
    @Override
    public byte[] getDataBytes() {
        byte[] blockData = new byte[0];
        blockData = appendBytes(blockData, SerializationUtils.serialize(this.timestamp));
        for(Transaction txn : this.data) {
            blockData = appendBytes(blockData, txn.getTxnHash());
        }
        blockData = appendBytes(blockData, SerializationUtils.serialize(this.previousBlockHash));
        blockData = appendBytes(blockData, SerializationUtils.serialize(this.nonce));
        blockData = appendBytes(blockData, this.signature);
        return blockData;
    }

    /**
     * Internal use only function. Used for facilitating the appending of the bytes
     * of data that are contained in the block.
     *
     * @param base
     * @param extension
     * @return
     */
    private static byte[] appendBytes(byte[] base, byte[] extension) {
        return ArrayUtils.addAll(base, extension);
    }

    /**
     * Builder class for facilitating the instantiation of blocks. This is to ensure some level
     * of data protection by enforcing non-direct data access and immutable data.
     */
    public static class Builder {

        private final static Logger logger = LoggerFactory.getLogger(Block.class);

        private BigInteger blockHeight;
        private ZonedDateTime timestamp;
        private byte[] merkleRoot;
        private List<Transaction> data;
        private byte[] previousBlock;
        private byte[] blockHash;
        private int nonce;

        private Builder(){}

        public static Builder newBuilder(){
            return new Builder();
        }

        public Builder setBlockHeight(BigInteger blockHeight) {
            this.blockHeight = blockHeight;
            return this;
        }

        public Builder setMerkleRoot(byte[] merkleRoot) {
            this.merkleRoot = merkleRoot;
            return this;
        }

        public Builder setData(List<Transaction> data){
            this.data = data;
            return this;
        }

        public Builder setPreviousBlock(byte[] previousBlock){
            this.previousBlock = previousBlock;
            return this;
        }

        public Block build() throws Exception {
            timestamp = DateTimeUtil.getCurrentTimestamp();
            return new Block(this);
        }

        /**
         * When a block header message is received, convert that message back into a
         * block in memory so it can be used properly. This will instantiate a skeleton
         * block...one that does not have any txns in it for the sake of identification
         * data only.
         *
         * @param blockHeaderPayload
         * @return block
         * @throws NoSuchAlgorithmException
         */
        public Block buildFromBlockHeaderMessage(BlockHeaderPayload blockHeaderPayload) throws NoSuchAlgorithmException {
            this.previousBlock = blockHeaderPayload.getPrevHash();
            // make a thing for the block height
            this.timestamp = DateTimeUtil.fromMessageTimestamp(blockHeaderPayload.getTimestamp());
            this.nonce = blockHeaderPayload.getNonce();
            this.blockHash = blockHeaderPayload.getHash();
            this.data = new ArrayList<>();
            Block blck = new Block(this);
            blck.setBlockHash(this.blockHash);
            return blck;
        }

        /**
         * When a full block message is received, convert that message back into a block
         * in memory so it can be used properly. This will result in instantiating a full
         * block, with txns for archival storage.
         *
         * @param blockMessage
         * @return
         * @throws NoSuchAlgorithmException
         * @throws InvalidKeySpecException
         * @throws NoSuchProviderException
         */
        public Block buildFromBlockMessage(BlockMessage blockMessage) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {
            // make a thing for the block height
            this.timestamp = DateTimeUtil.fromMessageTimestamp(blockMessage.getTimestamp());
            this.nonce = blockMessage.getNonce();
            this.blockHash = blockMessage.getBlockHash();
            this.previousBlock = blockMessage.getPreviousBlockHash();
            List<Transaction> data = new ArrayList<>();
            for(TransactionPayload txnPayload : blockMessage.getTxnPayloads()){
                data.add(Transaction.Builder.builder().buildFromMessage(txnPayload));
            }
            this.data = data;
            this.merkleRoot = blockMessage.getMerkleRoot();
            Block blck = new Block(this);
            if(CryptoHasher.isEqualHashes(this.blockHash, blck.blockHash)){
                logger.debug("Locally generated blockhash matched incoming blockhash from payload");
            } else {
                logger.debug("Locally generated blockhash did not match, manually setting blockhaash from payload");
                blck.setBlockHash(this.blockHash);
            }
            blck.setSignature(blockMessage.getSignature());
            return blck;
        }

    }

}
